import Head from 'next/head'
import Image from 'next/image'
import PokemonCard from '../components/PokemonCard';
import styles from '../styles/Home.module.css'
import React, { useState } from 'react';

function Home({ data, init, types }) {
  // Keep request data in the state to keep pagination links
  const [requestData, setData] = useState(data);
  // Unfiltered list of pokemon
  const [pokemon, setPokemon] = useState(init);
  // Filtered pokemon based on search input field
  const [results, setResults] = useState(null);
  // Set initial search and filter parameters to empty string
  const [search, setSearch] = useState('');
  const [filterType, setFilterType] = useState('');
  // Set booleans for loading flag and error
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(false);

  // Helper function for pagination
  async function fetchNextPage(url) {  
    setError(false);
    const res = await fetch(url);
    const data = await res.json();
  
    let results = data.results.map(async (e) => {
      const res = await fetch(e.url)
      return await res.json();
    });
    results  = await Promise.all(results);
  
    setData(data);
    setPokemon(results);

    return results;
  }

  // Helper function that fetches pokemon based on their type
  async function fetchByType(type) {  
    setError(false);
    setFilterType(type)
    let res, results;

    if (type) {
      res = await fetch(`https://pokeapi.co/api/v2/type/${type}/`);
      let data = await res.json();
      setData(data);
      results = data.pokemon.map(async (poke) => {
        const res = await fetch(poke?.pokemon?.url)
        return await res.json();
      });
    }
    // default request for all types  
    else {
      res = await fetch(`https://pokeapi.co/api/v2/pokemon`);
      let data = await res.json();
      setData(data);
      results = data.results.map(async (poke) => {
        const res = await fetch(poke?.url)
        return await res.json();
    })
    }
    results = await Promise.all(results);
  
    setPokemon(results);
    setResults(results);
    setIsLoading(false);
  }

  // Filter pokemon for fuzzy search of already loaded pokemon
    // If the pokemon is on the page already it won't require a search submission
  function filterBySearch(query) {
    setError(false);
    setSearch(query);
    const results = pokemon?.filter(p => p.name.includes(query.toLowerCase()));
    setResults(results);
  }

  // Fetch pokemon for full name query + submission
  // This is a workaround for the API limiting to 20 results at a time
  // If the pokemon is on the page already it won't require a new search
  async function fetchSearch(name) {
    let results;
    setIsLoading(true);
    // default to returning all pokemon if the user enters an empty search query
    if(!name) {
      let res = await fetch(`https://pokeapi.co/api/v2/pokemon`);
      let data = await res.json();
      setData(data);
      results = data.results.map(async (poke) => {
        const res = await fetch(poke?.url)
        return await res.json();
    })}
    else {
      await fetch(`https://pokeapi.co/api/v2/pokemon/${name}/`).then(async (response) => {
        if(response.status === 404) {
          setResults(null);
          setError(true);
          setIsLoading(false);
        } else {
          let data = await response.json();
          setData(data);
          setResults([data]);
        }
      })} 
    setIsLoading(false);
  }

  return (
      <div className={styles.container}>
        <Head>
          <title>Pokedex</title>
          <meta name="description" content="Generated by create next app" />
          <link rel="icon" href="/favicon.ico" />
        </Head>

        <main className={styles.main}>
          <div className={styles.header}>
            <div className={styles.headerContainer}> 
              <Image src="/logo.png" alt="Pokedex in Pokemon font" border="0" width="300" height="100" />
            </div>
          </div>

          <div className={styles.searchContainer}>
            <div className={styles.inputContainer}>
              <input id="search" placeholder='Search Pokemon' value={search} onChange={(e) => filterBySearch(e.target.value)} onKeyDown={(e) => {if (e.key === 'Enter') {{setIsLoading(true); fetchSearch(search)}}}}/>
              <button className={styles.searchButton} type="submit" onClick={() => {setIsLoading(true); fetchSearch(search)}}>Search</button>
            </div>
            <div className={styles.filterContainer}>
              <label htmlFor="search">Filter by Type: </label>
              <select name="filter" id="filter" value={filterType} onChange={(e) => {setIsLoading(true);  setError(false); fetchByType(e.target.value)}}>
                <option key="all" value="">All Types</option>
                {types && types.map((type) => {return <option key={type.name} value={type.name}>{type.name}</option>})}
              </select>
            </div>
           
          </div>

          {isLoading && 
            <div className={styles.loadingContainer}>   
              <Image src="/pokeball-loading.gif" alt="" border="0" width="175" height="130" /> 
            </div>
          } 
          {error && <div className={styles.loadingContainer}>No results found</div>} 
          <div className={styles.grid}>
            {!isLoading && !search && !error && pokemon?.map((pokemon) => {
              return <PokemonCard key={pokemon.name} pokemon={pokemon} />
            })}
            {search && !error && results?.map((pokemon) => {
              return <PokemonCard key={pokemon.name} pokemon={pokemon} />
            })}
          </div>

          {!isLoading && !search && <div className={styles.paginationContainer}>
            {requestData.previous &&
            <button className={styles.paginationButton} onClick={() => {fetchNextPage(requestData.next)}}>
              <Image alt="Pokeball" src="/pokeball.png" width="50" height="50"></Image>
              <div className={styles.paginationButtonText}>Prev</div>
            </button>
            }
            {requestData.next && <button className={styles.paginationButton} onClick={() => {fetchNextPage(requestData.next)}}>
              <Image alt="Pokeball" src="/pokeball.png" width="50" height="50"></Image>
              <div className={styles.paginationButtonText}>Next</div>
            </button>
            } 
          </div>
        }
        </main>
      </div>
  )
}

// Take advantage of SSR for initial load
export async function getServerSideProps() {
  // Fetch initial data, 20 pokemon are returned
  const res = await fetch('https://pokeapi.co/api/v2/pokemon/');
  const data = await res.json();

  // The API is structured to return {name, url}, where the URL is the API endpoint for that pokemon,
  // So do another batch of requests to actually get the pokemon data to fill the cards.
  let results = data.results.map(async (e) => {
    const res = await fetch(e.url)
    return await res.json();
  });
  results  = await Promise.all(results);

  // Request to grab pokemon types
  const typeReq = await fetch('https://pokeapi.co/api/v2/type/');
  const typesRes = await typeReq.json();

  // The last two types return no results so splicing to avoid empty categories
  const types = typesRes.results.splice(0, (results.length - 2))

  return { props: { data, init: results, types} }
}

export default Home